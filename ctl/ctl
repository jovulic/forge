#!/usr/bin/env bash
# This script was generated by bashly 1.2.10 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
	printf "bash version 4 or higher is required\n" >&2
	exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
	echo "$version"
}

# :command.usage
ctl_usage() {
	printf "ctl\n\n"

	printf "%s\n" "Usage:"
	printf "  ctl COMMAND\n"
	printf "  ctl [COMMAND] --help | -h\n"
	printf "  ctl --version | -v\n"
	echo
	# :command.usage_commands
	printf "%s\n" "Commands:"
	printf "  %s   Regenerate bashly.\n" "bashly"
	printf "  %s   Apply configuration.\n" "apply "
	printf "  %s   Update flake dependencies.\n" "update"
	printf "  %s   Perform garbage collection.\n" "clean "
	echo

	# :command.long_usage
	if [[ -n "$long_usage" ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo
		printf "  %s\n" "--version, -v"
		printf "    Show version number\n"
		echo

	fi
}

# :command.usage
ctl_bashly_usage() {
	printf "ctl bashly - Regenerate bashly.\n\n"

	printf "%s\n" "Usage:"
	printf "  ctl bashly\n"
	printf "  ctl bashly --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n "$long_usage" ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
ctl_apply_usage() {
	printf "ctl apply - Apply configuration.\n\n"

	printf "%s\n" "Usage:"
	printf "  ctl apply [NAME] [HOST] [OPTIONS]\n"
	printf "  ctl apply --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n "$long_usage" ]]; then
		printf "%s\n" "Options:"

		# :command.usage_flags
		# :flag.usage
		printf "  %s\n" "--dry"
		printf "    Print actions without performing them.\n"
		echo

		# :flag.usage
		printf "  %s\n" "--yes"
		printf "    Accept actions automatically.\n"
		echo

		# :flag.usage
		printf "  %s\n" "--keep-going"
		printf "    Keep going despite encountering errors.\n"
		echo

		# :flag.usage
		printf "  %s\n" "--repair"
		printf "    Repair corrupted store paths.\n"
		echo

		# :flag.usage
		printf "  %s\n" "--show-trace"
		printf "    Display tracebacks on errors.\n"
		echo

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "%s\n" "Arguments:"

		# :argument.usage
		printf "  %s\n" "NAME"
		printf "    Apply a specific configuration.\n"
		printf "    %s\n" "Allowed: system, home"
		echo

		# :argument.usage
		printf "  %s\n" "HOST"
		printf "    Apply a specific host.\n"
		printf "    %s\n" "Allowed: licious, expert"
		echo

	fi
}

# :command.usage
ctl_update_usage() {
	printf "ctl update - Update flake dependencies.\n\n"

	printf "%s\n" "Usage:"
	printf "  ctl update [NAME]\n"
	printf "  ctl update --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n "$long_usage" ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "%s\n" "Arguments:"

		# :argument.usage
		printf "  %s\n" "NAME"
		printf "    Update a specific input.\n"
		echo

	fi
}

# :command.usage
ctl_clean_usage() {
	printf "ctl clean - Perform garbage collection.\n\n"

	printf "%s\n" "Usage:"
	printf "  ctl clean [OPTIONS]\n"
	printf "  ctl clean --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n "$long_usage" ]]; then
		printf "%s\n" "Options:"

		# :command.usage_flags
		# :flag.usage
		printf "  %s\n" "--dry"
		printf "    Print actions without performing them.\n"
		echo

		# :flag.usage
		printf "  %s\n" "--yes"
		printf "    Accept actions automatically.\n"
		echo

		# :flag.usage
		printf "  %s\n" "--no-gc"
		printf "    Don't run nix store --gc.\n"
		echo

		# :flag.usage
		printf "  %s\n" "--no-gcroots"
		printf "    Don't clean gcroots.\n"
		echo

		# :flag.usage
		printf "  %s\n" "--optimise"
		printf "    Run nix-store --optimise after gc.\n"
		echo

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
	local arg passthru flags
	passthru=false

	while [[ $# -gt 0 ]]; do
		arg="$1"
		if [[ $passthru == true ]]; then
			input+=("$arg")
		elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
			input+=("${BASH_REMATCH[1]}")
			input+=("${BASH_REMATCH[2]}")
		elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
			input+=("${BASH_REMATCH[1]}")
			input+=("${BASH_REMATCH[2]}")
		elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
			flags="${BASH_REMATCH[1]}"
			for ((i = 0; i < ${#flags}; i++)); do
				input+=("-${flags:i:1}")
			done
		elif [[ "$arg" == "--" ]]; then
			passthru=true
			input+=("$arg")
		else
			input+=("$arg")
		fi

		shift
	done
}

# :command.inspect_args
inspect_args() {
	if ((${#args[@]})); then
		readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
		echo args:
		for k in "${sorted_keys[@]}"; do
			echo "- \${args[$k]} = ${args[$k]}"
		done
	else
		echo args: none
	fi

	if ((${#deps[@]})); then
		readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
		echo
		echo deps:
		for k in "${sorted_keys[@]}"; do
			echo "- \${deps[$k]} = ${deps[$k]}"
		done
	fi

	if ((${#env_var_names[@]})); then
		readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
		echo
		echo "environment variables:"
		for k in "${sorted_names[@]}"; do
			echo "- \$$k = ${!k:-}"
		done
	fi
}

# :command.command_functions
# :command.function
ctl_bashly_command() {

	# src/bashly_command.sh
	# shellcheck shell=bash

	set -efo pipefail

	root=$(git rev-parse --show-toplevel)
	(cd "$root/ctl" && bashly generate)
	direnv reload

}

# :command.function
ctl_apply_command() {

	# src/apply_command.sh
	# shellcheck shell=bash

	set -efo pipefail

	echo "apply" | figlet

	apply_system() {
		echo "system" | figlet
		local command=("nh" "os" "switch")

		if [[ -n "${args['--dry']}" ]]; then
			command+=("--dry")
		fi

		if [[ -z "${args['--yes']}" ]]; then
			command+=("--ask")
		fi

		if [[ -n "${args['--keep-going']}" ]]; then
			command+=("--keep-going")
		fi

		if [[ -n "${args['--repair']}" ]]; then
			command+=("--repair")
		fi

		if [[ -n "${args['--show-trace']}" ]]; then
			command+=("--show-trace")
		fi

		command+=(".")

		if [[ -n "${args[name]}" ]]; then
			command+=("${args[name]}")
		fi

		"${command[@]}"
	}

	apply_home() {
		echo "home" | figlet
		local command=("nh" "home" "switch")

		if [[ -n "${args['--dry']}" ]]; then
			command+=("--dry")
		fi

		if [[ -z "${args['--yes']}" ]]; then
			command+=("--ask")
		fi

		if [[ -n "${args['--keep-going']}" ]]; then
			command+=("--keep-going")
		fi

		if [[ -n "${args['--repair']}" ]]; then
			command+=("--repair")
		fi

		if [[ -n "${args['--show-trace']}" ]]; then
			command+=("--show-trace")
		fi

		command+=(".")

		if [[ -n "${args[name]}" ]]; then
			command+=("${args[name]}")
		fi

		"${command[@]}"
	}

	sudo -v # refresh sudo

	# shellcheck disable=SC2154
	name="${args[name]}"

	case "$name" in
	"system") apply_system ;;
	"home") apply_home ;;
	"")
		apply_system
		apply_home
		;;
	"*")
		echo "invalid name ${args[name]}"
		exit 1
		;;
	esac

	# # Refresh sudo credentials if necessary.
	# sudo -v
	#
	# # shellcheck disable=SC2154
	# name="${args[name]}"
	#
	# case "$name" in
	# "system") nixos-rebuild switch --sudo --flake . ;;
	# "home") home-manager switch --flake . ;;
	# "")
	# 	echo "applying system configuration..."
	# 	nixos-rebuild switch --option eval-cache false --sudo --flake .
	# 	echo "finished applying system configuration"
	#
	# 	echo "applying home configuration..."
	# 	home-manager switch --flake .
	# 	echo "finished applying home configuration"
	# 	;;
	# "*")
	# 	echo "invalid name ${args[name]}"
	# 	exit 1
	# 	;;
	# esac

}

# :command.function
ctl_update_command() {

	# src/update_command.sh
	# shellcheck shell=bash

	set -efo pipefail

	echo "update" | figlet

	command=("nix" "flake" "update")

	if [[ -n "${args['name']}" ]]; then
		command+=("${args['name']}")
	fi

	"${command[@]}"

}

# :command.function
ctl_clean_command() {

	# src/clean_command.sh
	# shellcheck shell=bash

	set -efo pipefail

	echo "clean" | figlet

	sudo -v # refresh sudo

	command=("nh" "clean" "all" "--keep-one")

	if [[ -n "${args['--dry']}" ]]; then
		command+=("--dry")
	fi

	if [[ -z "${args['--yes']}" ]]; then
		command+=("--ask")
	fi

	if [[ -n "${args['--no-gc']}" ]]; then
		command+=("--no-gc")
	fi

	if [[ -n "${args['--no-gcroots']}" ]]; then
		command+=("--no-gcroots")
	fi

	if [[ -n "${args['--optimise']}" ]]; then
		command+=("--optimise")
	fi

	"${command[@]}"

	# Refresh sudo credentials if necessary.
	# sudo -v
	#
	# if [[ -n "${args[--menu]}" ]]; then
	# 	echo "cleaning menu"
	# 	sudo nix-env --delete-generations old --profile /nix/var/nix/profiles/system
	# 	echo "finished cleaning menu"
	# fi
	#
	# echo "running garbage collection"
	# nix-store --gc
	# echo "finished garbage collection"
	#
	# if [[ -n "${args[--optimize]}" ]]; then
	# 	echo "deduplication running... This may take awhile"
	# 	nix-store --optimise
	# 	echo "finished deduplication"
	# fi

}

# :command.parse_requirements
parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			--version | -v)
				version_command
				exit
				;;

			--help | -h)
				long_usage=yes
				ctl_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action=${1:-}

	case $action in
		-*) ;;

		bashly)
			action="bashly"
			shift
			ctl_bashly_parse_requirements "$@"
			shift $#
			;;

		apply)
			action="apply"
			shift
			ctl_apply_parse_requirements "$@"
			shift $#
			;;

		update)
			action="update"
			shift
			ctl_update_parse_requirements "$@"
			shift $#
			;;

		clean)
			action="clean"
			shift
			ctl_clean_parse_requirements "$@"
			shift $#
			;;

		# :command.command_fallback
		"")
			ctl_usage >&2
			exit 1
			;;

		*)
			printf "invalid command: %s\n" "$action" >&2
			exit 1
			;;

	esac

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
ctl_bashly_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			--help | -h)
				long_usage=yes
				ctl_bashly_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.dependencies_filter
	missing_deps=
	# :dependency.filter
	if ! command -v bashly >/dev/null 2>&1; then
		printf "missing dependency: bashly\n" >&2
		missing_deps=1
	else
		deps['bashly']="$(command -v bashly | head -n1)"
	fi

	if [[ -n $missing_deps ]]; then
		exit 1
	fi

	# :command.command_filter
	action="bashly"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
ctl_apply_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			--help | -h)
				long_usage=yes
				ctl_apply_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.dependencies_filter
	missing_deps=
	# :dependency.filter
	if ! command -v figlet >/dev/null 2>&1; then
		printf "missing dependency: figlet\n" >&2
		missing_deps=1
	else
		deps['figlet']="$(command -v figlet | head -n1)"
	fi

	# :dependency.filter
	if ! command -v nh >/dev/null 2>&1; then
		printf "missing dependency: nh\n" >&2
		missing_deps=1
	else
		deps['nh']="$(command -v nh | head -n1)"
	fi

	if [[ -n $missing_deps ]]; then
		exit 1
	fi

	# :command.command_filter
	action="apply"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			# :flag.case
			--dry)

				# :flag.case_no_arg
				args['--dry']=1
				shift
				;;

			# :flag.case
			--yes)

				# :flag.case_no_arg
				args['--yes']=1
				shift
				;;

			# :flag.case
			--keep-going)

				# :flag.case_no_arg
				args['--keep-going']=1
				shift
				;;

			# :flag.case
			--repair)

				# :flag.case_no_arg
				args['--repair']=1
				shift
				;;

			# :flag.case
			--show-trace)

				# :flag.case_no_arg
				args['--show-trace']=1
				shift
				;;

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				# :argument.case
				if [[ -z ${args['name']+x} ]]; then
					args['name']=$1
					shift
				# :argument.case
				elif [[ -z ${args['host']+x} ]]; then
					args['host']=$1
					shift
				else
					printf "invalid argument: %s\n" "$key" >&2
					exit 1
				fi

				;;

		esac
	done

	# :command.whitelist_filter
	if [[ -n ${args['name']:-} ]] && [[ ! ${args['name']:-} =~ ^(system|home)$ ]]; then
		printf "%s\n" "name must be one of: system, home" >&2
		exit 1
	fi
	if [[ -n ${args['host']:-} ]] && [[ ! ${args['host']:-} =~ ^(licious|expert)$ ]]; then
		printf "%s\n" "host must be one of: licious, expert" >&2
		exit 1
	fi

}

# :command.parse_requirements
ctl_update_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			--help | -h)
				long_usage=yes
				ctl_update_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.dependencies_filter
	missing_deps=
	# :dependency.filter
	if ! command -v figlet >/dev/null 2>&1; then
		printf "missing dependency: figlet\n" >&2
		missing_deps=1
	else
		deps['figlet']="$(command -v figlet | head -n1)"
	fi

	# :dependency.filter
	if ! command -v nix >/dev/null 2>&1; then
		printf "missing dependency: nix\n" >&2
		missing_deps=1
	else
		deps['nix']="$(command -v nix | head -n1)"
	fi

	if [[ -n $missing_deps ]]; then
		exit 1
	fi

	# :command.command_filter
	action="update"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				# :argument.case
				if [[ -z ${args['name']+x} ]]; then
					args['name']=$1
					shift
				else
					printf "invalid argument: %s\n" "$key" >&2
					exit 1
				fi

				;;

		esac
	done

}

# :command.parse_requirements
ctl_clean_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			--help | -h)
				long_usage=yes
				ctl_clean_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.dependencies_filter
	missing_deps=
	# :dependency.filter
	if ! command -v figlet >/dev/null 2>&1; then
		printf "missing dependency: figlet\n" >&2
		missing_deps=1
	else
		deps['figlet']="$(command -v figlet | head -n1)"
	fi

	# :dependency.filter
	if ! command -v nh >/dev/null 2>&1; then
		printf "missing dependency: nh\n" >&2
		missing_deps=1
	else
		deps['nh']="$(command -v nh | head -n1)"
	fi

	if [[ -n $missing_deps ]]; then
		exit 1
	fi

	# :command.command_filter
	action="clean"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			# :flag.case
			--dry)

				# :flag.case_no_arg
				args['--dry']=1
				shift
				;;

			# :flag.case
			--yes)

				# :flag.case_no_arg
				args['--yes']=1
				shift
				;;

			# :flag.case
			--no-gc)

				# :flag.case_no_arg
				args['--no-gc']=1
				shift
				;;

			# :flag.case
			--no-gcroots)

				# :flag.case_no_arg
				args['--no-gcroots']=1
				shift
				;;

			# :flag.case
			--optimise)

				# :flag.case_no_arg
				args['--optimise']=1
				shift
				;;

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.initialize
initialize() {
	declare -g version="0.1.0"
	set -e

	# src/initialize.sh

}

# :command.run
run() {
	# :command.globals
	declare -g long_usage=''
	declare -g -A args=()
	declare -g -A deps=()
	declare -g -a env_var_names=()
	declare -g -a input=()

	normalize_input "$@"
	parse_requirements "${input[@]}"

	case "$action" in
		"bashly") ctl_bashly_command ;;
		"apply") ctl_apply_command ;;
		"update") ctl_update_command ;;
		"clean") ctl_clean_command ;;
	esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
	initialize
	run "$@"
fi
