#!/usr/bin/env bash
# This script was generated by bashly 1.2.6 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
	printf "bash version 4 or higher is required\n" >&2
	exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
	echo "$version"
}

# :command.usage
ctl_usage() {
	printf "ctl\n\n"

	printf "%s\n" "Usage:"
	printf "  ctl COMMAND\n"
	printf "  ctl [COMMAND] --help | -h\n"
	printf "  ctl --version | -v\n"
	echo
	# :command.usage_commands
	printf "%s\n" "Commands:"
	printf "  %s   Regenerate bashly.\n" "bashly "
	printf "  %s   Apply configuration.\n" "apply  "
	printf "  %s   Update flake dependencies.\n" "update "
	printf "  %s   Perform garbage collection.\n" "clean  "
	printf "  %s   Compile a package.\n" "compile"
	echo

	# :command.long_usage
	if [[ -n "$long_usage" ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo
		printf "  %s\n" "--version, -v"
		printf "    Show version number\n"
		echo

	fi
}

# :command.usage
ctl_bashly_usage() {
	printf "ctl bashly - Regenerate bashly.\n\n"

	printf "%s\n" "Usage:"
	printf "  ctl bashly\n"
	printf "  ctl bashly --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n "$long_usage" ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
ctl_apply_usage() {
	printf "ctl apply - Apply configuration.\n\n"

	printf "%s\n" "Usage:"
	printf "  ctl apply [NAME]\n"
	printf "  ctl apply --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n "$long_usage" ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "%s\n" "Arguments:"

		# :argument.usage
		printf "  %s\n" "NAME"
		printf "    Apply only specific configuration (system or home).\n"
		printf "    %s\n" "Allowed: system, home"
		echo

	fi
}

# :command.usage
ctl_update_usage() {
	printf "ctl update - Update flake dependencies.\n\n"

	printf "%s\n" "Usage:"
	printf "  ctl update\n"
	printf "  ctl update --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n "$long_usage" ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
ctl_clean_usage() {
	printf "ctl clean - Perform garbage collection.\n\n"

	printf "%s\n" "Usage:"
	printf "  ctl clean [OPTIONS]\n"
	printf "  ctl clean --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n "$long_usage" ]]; then
		printf "%s\n" "Options:"

		# :command.usage_flags
		# :flag.usage
		printf "  %s\n" "--optimize"
		printf "    Perform store optimisation (deduplication).\n"
		echo

		# :flag.usage
		printf "  %s\n" "--menu"
		printf "    Clean boot menu.\n"
		echo

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
ctl_compile_usage() {
	printf "ctl compile - Compile a package.\n\n"

	printf "%s\n" "Usage:"
	printf "  ctl compile COMMAND\n"
	printf "  ctl compile [COMMAND] --help | -h\n"
	echo
	# :command.usage_commands
	printf "%s\n" "Commands:"
	printf "  %s   Compile the bashly package.\n" "bashly"
	echo

	# :command.long_usage
	if [[ -n "$long_usage" ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
ctl_compile_bashly_usage() {
	printf "ctl compile bashly - Compile the bashly package.\n\n"

	printf "%s\n" "Usage:"
	printf "  ctl compile bashly [OPTIONS]\n"
	printf "  ctl compile bashly --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n "$long_usage" ]]; then
		printf "%s\n" "Options:"

		# :command.usage_flags
		# :flag.usage
		printf "  %s\n" "--init"
		printf "    Perform package initialization.\n"
		echo

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
	local arg passthru flags
	passthru=false

	while [[ $# -gt 0 ]]; do
		arg="$1"
		if [[ $passthru == true ]]; then
			input+=("$arg")
		elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
			input+=("${BASH_REMATCH[1]}")
			input+=("${BASH_REMATCH[2]}")
		elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
			input+=("${BASH_REMATCH[1]}")
			input+=("${BASH_REMATCH[2]}")
		elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
			flags="${BASH_REMATCH[1]}"
			for ((i = 0; i < ${#flags}; i++)); do
				input+=("-${flags:i:1}")
			done
		elif [[ "$arg" == "--" ]]; then
			passthru=true
			input+=("$arg")
		else
			input+=("$arg")
		fi

		shift
	done
}

# :command.inspect_args
inspect_args() {
	if ((${#args[@]})); then
		readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
		echo args:
		for k in "${sorted_keys[@]}"; do
			echo "- \${args[$k]} = ${args[$k]}"
		done
	else
		echo args: none
	fi

	if ((${#other_args[@]})); then
		echo
		echo other_args:
		echo "- \${other_args[*]} = ${other_args[*]}"
		for i in "${!other_args[@]}"; do
			echo "- \${other_args[$i]} = ${other_args[$i]}"
		done
	fi

	if ((${#deps[@]})); then
		readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
		echo
		echo deps:
		for k in "${sorted_keys[@]}"; do
			echo "- \${deps[$k]} = ${deps[$k]}"
		done
	fi

	if ((${#env_var_names[@]})); then
		readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
		echo
		echo "environment variables:"
		for k in "${sorted_names[@]}"; do
			echo "- \$$k = ${!k:-}"
		done
	fi
}

# :command.command_functions
# :command.function
ctl_bashly_command() {

	# src/bashly_command.sh
	# shellcheck shell=bash

	set -efo pipefail

	root=$(git rev-parse --show-toplevel)
	(cd "$root/ctl" && bashly generate)
	direnv reload

}

# :command.function
ctl_apply_command() {

	# src/apply_command.sh
	# shellcheck shell=bash

	set -efo pipefail

	echo "apply" | figlet

	# Refresh sudo credentials if necessary.
	sudo -v

	# shellcheck disable=SC2154
	name="${args[name]}"

	case "$name" in
	"system") nixos-rebuild switch --use-remote-sudo --flake . ;;
	"home") home-manager switch --flake . ;;
	"")
		echo "Applying system configuration..."
		nixos-rebuild switch --option eval-cache false --use-remote-sudo --flake .
		# nixos-rebuild switch --use-remote-sudo --flake .
		echo "Finished applying system configuration."

		echo "Applying home configuration..."
		home-manager switch --flake .
		echo "Finished applying home configuration."
		;;
	"*")
		echo "Invalid name ${args[name]}."
		exit 1
		;;
	esac

}

# :command.function
ctl_update_command() {

	# src/update_command.sh
	# shellcheck shell=bash

	set -efo pipefail

	echo "update" | figlet

	nix flake update

}

# :command.function
ctl_clean_command() {

	# src/clean_command.sh
	# shellcheck shell=bash

	set -efo pipefail

	echo "clean" | figlet

	# Refresh sudo credentials if necessary.
	sudo -v

	if [[ -n "${args[--menu]}" ]]; then
		echo "Cleaning menu."
		sudo nix-env --delete-generations old --profile /nix/var/nix/profiles/system
		echo "Finished cleaning menu."
	fi

	echo "Running garbage collection."
	nix-store --gc
	echo "Finished garbage collection."

	if [[ -n "${args[--optimize]}" ]]; then
		echo "Deduplication running... This may take awhile."
		nix-store --optimise
		echo "Finished deduplication."
	fi

}

# :command.function
ctl_compile_bashly_command() {

	# src/compile_bashly_command.sh
	# shellcheck shell=bash

	set -efo pipefail

	echo "compile:bashly" | figlet

	# ref: https://github.com/NixOS/nixpkgs/blob/master/doc/languages-frameworks/ruby.section.md

	if [[ -n "${args[--init]}" ]]; then
		(
			cd pkgs/bashly
			cat <<-EOF >Gemfile
			source "https://rubygems.org"
			gem "bashly"
		EOF
	)
fi

(
	cd pkgs/bashly
	bundle lock
	bundix
)

}

# :command.parse_requirements
parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			--version | -v)
				version_command
				exit
				;;

			--help | -h)
				long_usage=yes
				ctl_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action=${1:-}

	case $action in
		-*) ;;

		bashly)
			action="bashly"
			shift
			ctl_bashly_parse_requirements "$@"
			shift $#
			;;

		apply)
			action="apply"
			shift
			ctl_apply_parse_requirements "$@"
			shift $#
			;;

		update)
			action="update"
			shift
			ctl_update_parse_requirements "$@"
			shift $#
			;;

		clean)
			action="clean"
			shift
			ctl_clean_parse_requirements "$@"
			shift $#
			;;

		compile)
			action="compile"
			shift
			ctl_compile_parse_requirements "$@"
			shift $#
			;;

		# :command.command_fallback
		"")
			ctl_usage >&2
			exit 1
			;;

		*)
			printf "invalid command: %s\n" "$action" >&2
			exit 1
			;;

	esac

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
ctl_bashly_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			--help | -h)
				long_usage=yes
				ctl_bashly_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.dependencies_filter
	if command -v bashly >/dev/null 2>&1; then
		deps['bashly']="$(command -v bashly | head -n1)"
	else
		printf "missing dependency: bashly\n" >&2
		exit 1
	fi

	# :command.command_filter
	action="bashly"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
ctl_apply_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			--help | -h)
				long_usage=yes
				ctl_apply_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.dependencies_filter
	if command -v figlet >/dev/null 2>&1; then
		deps['figlet']="$(command -v figlet | head -n1)"
	else
		printf "missing dependency: figlet\n" >&2
		exit 1
	fi

	if command -v nixos-rebuild >/dev/null 2>&1; then
		deps['nixos-rebuild']="$(command -v nixos-rebuild | head -n1)"
	else
		printf "missing dependency: nixos-rebuild\n" >&2
		exit 1
	fi

	if command -v home-manager >/dev/null 2>&1; then
		deps['home-manager']="$(command -v home-manager | head -n1)"
	else
		printf "missing dependency: home-manager\n" >&2
		exit 1
	fi

	# :command.command_filter
	action="apply"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				# :argument.case
				if [[ -z ${args['name']+x} ]]; then
					args['name']=$1
					shift
				else
					printf "invalid argument: %s\n" "$key" >&2
					exit 1
				fi

				;;

		esac
	done

	# :command.whitelist_filter
	if [[ -n ${args['name']:-} ]] && [[ ! ${args['name']:-} =~ ^(system|home)$ ]]; then
		printf "%s\n" "name must be one of: system, home" >&2
		exit 1
	fi

}

# :command.parse_requirements
ctl_update_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			--help | -h)
				long_usage=yes
				ctl_update_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.dependencies_filter
	if command -v figlet >/dev/null 2>&1; then
		deps['figlet']="$(command -v figlet | head -n1)"
	else
		printf "missing dependency: figlet\n" >&2
		exit 1
	fi

	if command -v nix >/dev/null 2>&1; then
		deps['nix']="$(command -v nix | head -n1)"
	else
		printf "missing dependency: nix\n" >&2
		exit 1
	fi

	# :command.command_filter
	action="update"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
ctl_clean_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			--help | -h)
				long_usage=yes
				ctl_clean_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.dependencies_filter
	if command -v figlet >/dev/null 2>&1; then
		deps['figlet']="$(command -v figlet | head -n1)"
	else
		printf "missing dependency: figlet\n" >&2
		exit 1
	fi

	if command -v nix-store >/dev/null 2>&1; then
		deps['nix-store']="$(command -v nix-store | head -n1)"
	else
		printf "missing dependency: nix-store\n" >&2
		exit 1
	fi

	if command -v nix-env >/dev/null 2>&1; then
		deps['nix-env']="$(command -v nix-env | head -n1)"
	else
		printf "missing dependency: nix-env\n" >&2
		exit 1
	fi

	# :command.command_filter
	action="clean"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			# :flag.case
			--optimize)

				# :flag.case_no_arg
				args['--optimize']=1
				shift
				;;

			# :flag.case
			--menu)

				# :flag.case_no_arg
				args['--menu']=1
				shift
				;;

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
ctl_compile_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			--help | -h)
				long_usage=yes
				ctl_compile_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action=${1:-}

	case $action in
		-*) ;;

		bashly)
			action="bashly"
			shift
			ctl_compile_bashly_parse_requirements "$@"
			shift $#
			;;

		# :command.command_fallback
		"")
			ctl_compile_usage >&2
			exit 1
			;;

		*)
			printf "invalid command: %s\n" "$action" >&2
			exit 1
			;;

	esac

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
ctl_compile_bashly_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			--help | -h)
				long_usage=yes
				ctl_compile_bashly_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.dependencies_filter
	if command -v figlet >/dev/null 2>&1; then
		deps['figlet']="$(command -v figlet | head -n1)"
	else
		printf "missing dependency: figlet\n" >&2
		exit 1
	fi

	if command -v bundle >/dev/null 2>&1; then
		deps['bundle']="$(command -v bundle | head -n1)"
	else
		printf "missing dependency: bundle\n" >&2
		exit 1
	fi

	if command -v bundix >/dev/null 2>&1; then
		deps['bundix']="$(command -v bundix | head -n1)"
	else
		printf "missing dependency: bundix\n" >&2
		exit 1
	fi

	# :command.command_filter
	action="compile bashly"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			# :flag.case
			--init)

				# :flag.case_no_arg
				args['--init']=1
				shift
				;;

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.initialize
initialize() {
	version="0.1.0"
	long_usage=''
	set -e

	# src/initialize.sh

}

# :command.run
run() {
	declare -g -A args=()
	declare -g -A deps=()
	declare -g -a other_args=()
	declare -g -a env_var_names=()
	declare -g -a input=()
	normalize_input "$@"
	parse_requirements "${input[@]}"

	case "$action" in
		"bashly") ctl_bashly_command ;;
		"apply") ctl_apply_command ;;
		"update") ctl_update_command ;;
		"clean") ctl_clean_command ;;
		"compile") ctl_compile_command ;;
		"compile bashly") ctl_compile_bashly_command ;;
	esac
}

initialize
run "$@"
